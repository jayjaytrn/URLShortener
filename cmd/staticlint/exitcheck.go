// Package main provides a multichecker tool for static analysis of Go code.
//
// This tool aggregates multiple static analysis tools to perform comprehensive
// code checks. It includes standard Go analyzers, Staticcheck analyzers,
// additional third-party analyzers, and a custom analyzer to enforce
// restrictions on the use of os.Exit in main functions.
//
// The tool is designed to be executed using:
//
//	go run -trimpath ./cmd/staticlint ./...
//
// The output consists of errors and warnings generated by the included analyzers.
// It supports filtering analyzers via a configuration file (e.g., staticcheck.conf).
package main

import (
	"go/ast"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/multichecker"
	"path/filepath"
	"strings"

	// Import standard Go analyzers
	"golang.org/x/tools/go/analysis/passes/appends"
	"golang.org/x/tools/go/analysis/passes/asmdecl"
	"golang.org/x/tools/go/analysis/passes/assign"
	"golang.org/x/tools/go/analysis/passes/atomic"
	"golang.org/x/tools/go/analysis/passes/atomicalign"
	"golang.org/x/tools/go/analysis/passes/bools"
	"golang.org/x/tools/go/analysis/passes/buildssa"
	"golang.org/x/tools/go/analysis/passes/buildtag"
	"golang.org/x/tools/go/analysis/passes/cgocall"
	"golang.org/x/tools/go/analysis/passes/composite"
	"golang.org/x/tools/go/analysis/passes/copylock"
	"golang.org/x/tools/go/analysis/passes/ctrlflow"
	"golang.org/x/tools/go/analysis/passes/deepequalerrors"
	"golang.org/x/tools/go/analysis/passes/errorsas"
	"golang.org/x/tools/go/analysis/passes/findcall"
	"golang.org/x/tools/go/analysis/passes/printf"
	"golang.org/x/tools/go/analysis/passes/shift"
	"golang.org/x/tools/go/analysis/passes/structtag"
	"golang.org/x/tools/go/analysis/passes/unreachable"
	"golang.org/x/tools/go/analysis/passes/unusedresult"
	"golang.org/x/tools/go/analysis/passes/unusedwrite"
	"golang.org/x/tools/go/analysis/passes/usesgenerics"

	// Import Staticcheck analyzers
	"honnef.co/go/tools/staticcheck"

	// Import additional third-party analyzers
	"github.com/gostaticanalysis/forcetypeassert"
	"github.com/gostaticanalysis/wraperrfmt"
)

// ExitCheckAnalyzer is a custom analyzer that prohibits the direct use of os.Exit in main functions.
//
// It scans the main function of packages named "main" and reports an error if os.Exit is found.
// It ignores generated files and vendor directories.
var ExitCheckAnalyzer = &analysis.Analyzer{
	Name: "exitcheck",
	Doc:  "Prohibits direct calls to os.Exit in the main function of the main package",
	Run:  runExitCheck,
}

// isGenerated checks if a file contains a "Code generated" comment, indicating that it is auto-generated.
func isGenerated(file *ast.File) bool {
	for _, cg := range file.Comments {
		if strings.Contains(cg.Text(), "Code generated") {
			return true
		}
	}
	return false
}

// runExitCheck inspects Go files to detect and report the direct usage of os.Exit in main functions.
func runExitCheck(pass *analysis.Pass) (interface{}, error) {
	// Perform analysis only for packages within the module
	if !strings.HasPrefix(pass.Pkg.Path(), "github.com/jayjaytrn/URLShortener") {
		return nil, nil
	}
	// Analyze only packages named "main"
	if pass.Pkg.Name() != "main" {
		return nil, nil
	}

	// Iterate over all files in the package
	for _, file := range pass.Files {
		// Skip generated files
		if isGenerated(file) {
			continue
		}
		// Search for the main function
		for _, decl := range file.Decls {
			fn, ok := decl.(*ast.FuncDecl)
			if !ok || fn.Name.Name != "main" {
				continue
			}
			// Inspect the body of the main function
			ast.Inspect(fn.Body, func(n ast.Node) bool {
				call, ok := n.(*ast.CallExpr)
				if !ok {
					return true
				}
				sel, ok := call.Fun.(*ast.SelectorExpr)
				if !ok {
					return true
				}
				ident, ok := sel.X.(*ast.Ident)
				if !ok {
					return true
				}
				// Report os.Exit usage
				if ident.Name == "os" && sel.Sel.Name == "Exit" {
					pos := pass.Fset.Position(call.Pos())
					if strings.Contains(pos.Filename, string(filepath.Separator)+"vendor"+string(filepath.Separator)) {
						return true
					}
					pass.Reportf(call.Pos(), "Direct call to os.Exit in main function is prohibited (file: %s, line: %d)", pos.Filename, pos.Line)
				}
				return true
			})
		}
	}
	return nil, nil
}

// main function initializes the multichecker and registers all analyzers.
func main() {
	analyzers := []*analysis.Analyzer{
		// Standard Go analyzers
		asmdecl.Analyzer,
		assign.Analyzer,
		atomic.Analyzer,
		atomicalign.Analyzer,
		bools.Analyzer,
		buildssa.Analyzer,
		buildtag.Analyzer,
		cgocall.Analyzer,
		composite.Analyzer,
		copylock.Analyzer,
		ctrlflow.Analyzer,
		deepequalerrors.Analyzer,
		errorsas.Analyzer,
		findcall.Analyzer,
		printf.Analyzer,
		shift.Analyzer,
		structtag.Analyzer,
		unreachable.Analyzer,
		unusedresult.Analyzer,
		unusedwrite.Analyzer,
		usesgenerics.Analyzer,
		appends.Analyzer,
		// Custom analyzer
		ExitCheckAnalyzer,
	}

	// Add Staticcheck analyzers
	for _, a := range staticcheck.Analyzers {
		if strings.HasPrefix(a.Analyzer.Name, "SA") {
			analyzers = append(analyzers, a.Analyzer)
		}
	}

	// Add additional third-party analyzers
	analyzers = append(analyzers, wraperrfmt.Analyzer, forcetypeassert.Analyzer)

	// Execute multichecker with all configured analyzers
	multichecker.Main(analyzers...)
}
